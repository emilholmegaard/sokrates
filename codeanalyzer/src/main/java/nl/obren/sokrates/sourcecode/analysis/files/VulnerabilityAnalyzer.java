/*
 * Copyright (c) 2023 Emil Holmegaard. All rights reserved.
 */

package nl.obren.sokrates.sourcecode.analysis.files;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;

import jakarta.xml.bind.DataBindingException;
import nl.obren.sokrates.common.utils.ProgressFeedback;
import nl.obren.sokrates.sourcecode.analysis.AnalysisUtils;
import nl.obren.sokrates.sourcecode.analysis.Analyzer;
import nl.obren.sokrates.sourcecode.analysis.results.CodeAnalysisResults;
import nl.obren.sokrates.sourcecode.analysis.vulnerabilities.Dependency;
import nl.obren.sokrates.sourcecode.analysis.vulnerabilities.Root;
import nl.obren.sokrates.sourcecode.analysis.vulnerabilities.VendorEvidence;
import nl.obren.sokrates.sourcecode.analysis.vulnerabilities.Vulnerability;
import nl.obren.sokrates.sourcecode.core.CodeConfiguration;
import nl.obren.sokrates.sourcecode.stats.RiskDistributionStats;
import nl.obren.sokrates.sourcecode.threshold.Thresholds;

public class VulnerabilityAnalyzer extends Analyzer {
    private final StringBuffer textSummary;
    private final CodeConfiguration codeConfiguration;
    private final long start;

    private CodeAnalysisResults analysisResults;
    private File root;
    private String[] severities = { "CRITICAL", "HIGH", "MEDIUM", "MODERATE", "LOW" };

    public VulnerabilityAnalyzer(CodeAnalysisResults analysisResults, File root) {

        this.codeConfiguration = analysisResults.getCodeConfiguration();
        this.root = root;
        this.start = analysisResults.getAnalysisStartTimeMs();
        this.textSummary = analysisResults.getTextSummary();
        this.analysisResults = analysisResults;

    }

    public void analyze(ProgressFeedback progressFeedback) {
        String dependencyFile = getPathForDependencyFile().toString();

        if (isSkipVulnerabilitiesIfNotExists()) {
            AnalysisUtils.info(textSummary, progressFeedback, "Dependency file not found: " + dependencyFile, start);

            return;
        }

        progressFeedback.start();
        AnalysisUtils.info(textSummary, progressFeedback, "Analysing / updating vulnerabilities...", start);

        AnalysisUtils.info(textSummary, progressFeedback, "Found dependency file: " + dependencyFile, start);
        ObjectMapper mapper = new ObjectMapper();
        mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
        try {

            Root json = mapper.readValue(new File(dependencyFile), Root.class);
            this.analysisResults.getVulnerabilitiesAnalysisResults().setRoot(json);

            if (json.dependencies != null) {
                int uniqueDependencies = getDependenciesSize(json);

                AnalysisUtils.detailedInfo(textSummary, progressFeedback,
                        "OWASP Dependency file has " + json.dependencies.size() + " dependencies with vulnerabilities",
                        start);
                this.analysisResults.getVulnerabilitiesAnalysisResults().setDependencies(json.dependencies);

                this.analysisResults.getVulnerabilitiesAnalysisResults()
                        .setTotalVulnerableDependencies(getVulnerabilitiesFound(json));

                AnalysisUtils.detailedInfo(textSummary, progressFeedback,
                        "OWASP Dependency file has " + uniqueDependencies + "unique dependencies", start);
                this.analysisResults.getVulnerabilitiesAnalysisResults()
                        .setTotalNumberOfThirdPartyDependencies(uniqueDependencies);

                this.analysisResults.getVulnerabilitiesAnalysisResults()
                        .setTotalNumberOfCves(getVulnerabilities(json));

                AnalysisUtils.detailedInfo(textSummary, progressFeedback,
                        "Find package information for OWASP dependency scan", start);
                this.analysisResults.getVulnerabilitiesAnalysisResults()
                        .setVulnerableDependenciesToPackage(getPackages(json));
                this.analysisResults.getVulnerabilitiesAnalysisResults()
                        .setVulnerableDependenciesToPackageUrl(getPackageUrl(json));

                AnalysisUtils.detailedInfo(textSummary, progressFeedback,
                        "Find vulnerability information for OWASP dependency scan", start);
                this.analysisResults.getVulnerabilitiesAnalysisResults()
                        .setVulnerableDependenciesToVulnerabilityId(getVulnerabilityIds(json));

                this.analysisResults.getVulnerabilitiesAnalysisResults()
                        .setVulnerableDependenciesToHighestSeverity(getHighestSeverity(json));

                this.analysisResults.getVulnerabilitiesAnalysisResults()
                        .setVulnerableDependencies(getVulnerableDependencies(json));
                        this.analysisResults.getVulnerabilitiesAnalysisResults()
                        .setVulnerableDependenciesToCVECount(getCVECount(json));


                AnalysisUtils.detailedInfo(textSummary, progressFeedback,
                        "Find evidence count for OWASP dependency scan", start);
                this.analysisResults.getVulnerabilitiesAnalysisResults()
                        .setVulnerableDependenciesToEvidenceCount(getEvidenceCount(json));

                AnalysisUtils.detailedInfo(textSummary, progressFeedback,
                        "Find severities for OWASP dependency scan", start);

                int critical = getMatch(this.severities[0], this.analysisResults.getVulnerabilitiesAnalysisResults()
                        .getVulnerableDependenciesToHighestSeverity());
                int high = getMatch(this.severities[1], this.analysisResults.getVulnerabilitiesAnalysisResults()
                        .getVulnerableDependenciesToHighestSeverity());

                int medium = getMatch(this.severities[2], this.analysisResults.getVulnerabilitiesAnalysisResults()
                        .getVulnerableDependenciesToHighestSeverity());

                int moderate = getMatch(this.severities[3], this.analysisResults.getVulnerabilitiesAnalysisResults()
                        .getVulnerableDependenciesToHighestSeverity());

                int low = getMatch(this.severities[4], this.analysisResults.getVulnerabilitiesAnalysisResults()
                        .getVulnerableDependenciesToHighestSeverity());

                AnalysisUtils.detailedInfo(textSummary, progressFeedback,
                        "OWASP Dependency file has " + critical + " critical entries", start);
                this.analysisResults.getVulnerabilitiesAnalysisResults().setTotalCriticalVulnerabilities(critical);
                AnalysisUtils.detailedInfo(textSummary, progressFeedback,
                        "OWASP Dependency file has " + high + " high entries", start);
                this.analysisResults.getVulnerabilitiesAnalysisResults().setTotalHighVulnerabilities(high);
                AnalysisUtils.detailedInfo(textSummary, progressFeedback,
                        "OWASP Dependency file has " + medium + " medium entries", start);
                this.analysisResults.getVulnerabilitiesAnalysisResults().setTotalMediumVulnerabilities(medium);
                AnalysisUtils.detailedInfo(textSummary, progressFeedback,
                        "OWASP Dependency file has " + moderate + " moderate entries", start);
                this.analysisResults.getVulnerabilitiesAnalysisResults().setTotalModerateVulnerabilities(moderate);

                AnalysisUtils.detailedInfo(textSummary, progressFeedback,
                        "OWASP Dependency file has " + low + " low entries", start);
                this.analysisResults.getVulnerabilitiesAnalysisResults().setTotalLowVulnerabilities(low);

            }

        } catch (IOException | DataBindingException e) {
            AnalysisUtils.info(textSummary, progressFeedback,
                    "Error reading file / updating vulnerabilities... " + e.getMessage(),
                    start);

        }

    }

    private Path getPathForDependencyFile() {

        String strRootPath = ".";
        Path config = new File(strRootPath).toPath();
        return config.resolve(this.codeConfiguration.getVulnerability().getPathToJsonFile());
    }

    private boolean isSkipVulnerabilitiesIfNotExists() {
        return Files.notExists(getPathForDependencyFile());

    }


    //Potential for speed optimization here, as we loop json.dependencies in all the following units
    private HashMap<String, String[]> getPackages(Root json) {
        HashMap<String, String[]> packages = new HashMap<String, String[]>();
        if (json != null && json.dependencies != null) {
            for (Dependency dependency : json.dependencies) {
                if (dependency != null && dependency.packages != null) {
                    List<String> pList = dependency.packages.stream().filter(Objects::nonNull).map(t -> t.id)
                            .filter(Objects::nonNull).collect(Collectors.toList());
                    packages.put(dependency.fileName, pList.toArray(new String[0]));
                }
            }
        }
        return packages;
    }

    private HashMap<String, String> getPackageUrl(Root json) {
        HashMap<String, String> urls = new HashMap<String, String>();
        if (json != null && json.dependencies != null) {
            for (Dependency dependency : json.dependencies) {
                if (dependency != null && dependency.packages != null) {
                    List<String> pList = dependency.packages.stream().filter(Objects::nonNull).map(t -> t.url)
                            .filter(Objects::nonNull).collect(Collectors.toList());
                    urls.put(dependency.fileName, pList.get(0));
                }
            }
        }
        return urls;
    }

    private HashMap<String, String[]> getVulnerabilityIds(Root json) {
        HashMap<String, String[]> vulnerabilityIds = new HashMap<String, String[]>();
        if (json != null && json.dependencies != null) {
            for (Dependency dependency : json.dependencies) {
                if (dependency != null && dependency.vulnerabilityIds != null) {
                    List<String> vList = dependency.vulnerabilityIds.stream().filter(Objects::nonNull).map(t -> t.id)
                            .filter(Objects::nonNull).collect(Collectors.toList());
                    vulnerabilityIds.put(dependency.fileName, vList.toArray(new String[0]));

                }
            }
        }
        return vulnerabilityIds;
    }

    private HashMap<String, Integer> getEvidenceCount(Root json) {
        HashMap<String, Integer> evidences = new HashMap<String, Integer>();
        if (json != null && json.dependencies != null) {
            for (Dependency dependency : json.dependencies) {
                if (dependency != null && dependency.evidenceCollected != null) {
                    Integer count = dependency.evidenceCollected.vendorEvidence.size();
                    count += dependency.evidenceCollected.productEvidence.size();
                    count += dependency.evidenceCollected.versionEvidence.size();
                    evidences.put(dependency.fileName, count);

                }
            }
        }
        return evidences;
    }

    private HashMap<String, Integer> getCVECount(Root json) {
        HashMap<String, Integer> cves = new HashMap<String, Integer>();
        if (json != null && json.dependencies != null) {
            for (Dependency dependency : json.dependencies) {
                if (dependency != null && dependency.vulnerabilities != null) {
                    Integer count = dependency.vulnerabilities.size();
                   
                    cves.put(dependency.fileName, count);

                }
            }
        }
        return cves;
    }

    private int getDependenciesSize(Root json) {
        int dependencies = 0;
        if (json != null && json.dependencies != null) {
            dependencies = json.dependencies.size();
        }
        return dependencies;
    }

    private int getVulnerabilitiesFound(Root json) {
        int cVECount = 0;
        if (json != null && json.dependencies != null) {
            for (Dependency dependency : json.dependencies) {
                if (dependency.vulnerabilities != null) {
                    cVECount += dependency.vulnerabilities.size();
                }
            }
        }
        return cVECount;
    }

    private String[] getVulnerableDependencies(Root json) {
        List<String> vulnerableDependencies = new ArrayList<>();
        if (json != null && json.dependencies != null) {
            for (Dependency dependency : json.dependencies) {
                vulnerableDependencies.add(dependency.fileName);
            }
        }
        return vulnerableDependencies.toArray(new String[0]);
    }

    private int getVulnerabilities(Root json) {
        int cVECount = 0;
        if (json != null && json.dependencies != null) {
            for (Dependency dependency : json.dependencies) {
                if (dependency.vulnerabilities != null) {
                    cVECount += dependency.packages.size();
                }
            }
        }
        return cVECount;
    }

    private HashMap<String, String> getHighestSeverity(Root json) {
        HashMap<String, String> severityMap = new HashMap<String, String>();
        if (json != null && json.dependencies != null) {
            for (Dependency dependency : json.dependencies) {
                if (dependency != null && dependency.vulnerabilities != null) {
                    List<String> pList = dependency.vulnerabilities.stream().filter(Objects::nonNull)
                            .map(t -> t.severity.toLowerCase())
                            .filter(Objects::nonNull).collect(Collectors.toList());
                    for (String severity : this.severities) {
                        if (pList.contains(severity.toLowerCase())) {
                            {
                                severityMap.put(dependency.fileName, severity);
                                break;
                            }
                        }
                    }
                }
            }
        }
        return severityMap;
    }

    private int getMatch(String subject, HashMap<String, String> keyAndSubjects) {
        int subjectCount = 0;
        for (String value : keyAndSubjects.values()) {
            if (value.equalsIgnoreCase(subject)) {
                ++subjectCount;
            }
        }
        return subjectCount;
    }

}
