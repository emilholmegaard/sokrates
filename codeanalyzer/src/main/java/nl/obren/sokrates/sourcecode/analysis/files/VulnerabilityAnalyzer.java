/*
 * Copyright (c) 2021 Željko Obrenović. All rights reserved.
 */

 package nl.obren.sokrates.sourcecode.analysis.files;

 import nl.obren.sokrates.common.utils.ProcessingStopwatch;
 import nl.obren.sokrates.common.utils.ProgressFeedback;
import nl.obren.sokrates.sourcecode.analysis.CodeAnalyzerSettings;;
 import nl.obren.sokrates.sourcecode.analysis.AnalysisUtils;
 import nl.obren.sokrates.sourcecode.analysis.Analyzer;
 import nl.obren.sokrates.sourcecode.analysis.results.CodeAnalysisResults;
 import nl.obren.sokrates.sourcecode.aspects.LogicalDecomposition;
 import nl.obren.sokrates.sourcecode.aspects.NamedSourceCodeAspect;
 import nl.obren.sokrates.sourcecode.core.CodeConfiguration;

 import nl.obren.sokrates.sourcecode.analysis.vulnerabilities.*;
 
 import com.fasterxml.jackson.databind.ObjectMapper;
 import java.io.File;
 import java.util.*;
 
 public class VulnerabilityAnalyzer extends Analyzer {
     private final StringBuffer textSummary;
     private final CodeConfiguration codeConfiguration;
     private final long start;
   
     private final NamedSourceCodeAspect main;
     private CodeAnalysisResults analysisResults;
     private ProgressFeedback progressFeedback;
 
     public VulnerabilityAnalyzer(CodeAnalysisResults analysisResults) {
       
         this.codeConfiguration = analysisResults.getCodeConfiguration();
         this.start = analysisResults.getAnalysisStartTimeMs();
         this.textSummary = analysisResults.getTextSummary();
         this.analysisResults = analysisResults;
         this.main = codeConfiguration.getMain();
     }
 
     public void analyze(ProgressFeedback progressFeedback) {
         if (isSkipVulnerabilities()) {
             return;
         }
 
         this.progressFeedback = progressFeedback;
         progressFeedback.start();
         progressFeedback.setDetailedText("");
         AnalysisUtils.info(textSummary, progressFeedback, "Analysing / updating vulnerabilities...", start);
         
         if(this.codeConfiguration.getVulnerability().isDependencyCheckFile()){
            String dependencyFile = this.codeConfiguration.getVulnerability().getPathToJsonFile();
            ObjectMapper mapper = new ObjectMapper();
            Dependency[]  dependencies = mapper.readValue(new File(dependencyFile), Dependency[].class);

            for (Dependency dependency : dependencies) {
                dependency.
            }
         }
         
         
         
         
         
         
    }
 
     
     private boolean isSkipVulnerabilities() {
        //if json file does not exits
         return true;
     }
 
    }
 